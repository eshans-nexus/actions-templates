name: 'Module: AWS Smoke Test'

on:
  workflow_call:
    inputs:
      ami_id:
        required: true
        type: string
      flavor:
        required: true
        type: string
      matlab_version:
        required: true
        type: string
      region:
        required: true
        type: string
      metatemplate_file_path:
        required: true
        type: string
      run_security_scan:
        required: true
        type: boolean
    secrets:
      AWS_OIDC_ROLE:
        required: true
      TEST_VPC_ID:
        required: true
      TEST_SUBNET_ID:
        required: true
env:
  TEMPLATE_GEN_MODE: 'test'
  METATEMPLATE_PATH: "./${{ inputs.metatemplate_file_path }}"
  TEMPLATE_FILENAME: "${{ inputs.matlab_version }}-test-template.json"
  TEST_ARTIFACT_NAME: "${{ inputs.matlab_version }}-test-template"
  TEMP_SSH_KEY_AWS_NAME: "smoke-${{ github.run_id }}-${{ github.run_number }}-${{ inputs.matlab_version }}"
  TEMP_SSH_KEY_FILENAME: "private_key.pem"
  STACK_NAME: "msa-gen-smoke-test-${{ inputs.flavor }}-${{ inputs.matlab_version }}-${{ github.run_id }}"
  TEST_REGION_MAP: '{"${{ inputs.region }}": {"AMI": "${{ inputs.ami_id }}"}}'

jobs:
  smoke-test:
    name: "${{ inputs.matlab_version }}: Run smoke tests"
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Generate test template
        uses: eshans-nexus/actions-templates/.github/actions/create-aws-template@main
        with:
          region_map: ${{ env.TEST_REGION_MAP }}
          ami_id: ${{ inputs.ami_id }}
          output_filename: ${{ env.TEMPLATE_FILENAME }}
          artifact_name: ${{ env.TEST_ARTIFACT_NAME }}
          metatemplate_file_path: ${{ env.METATEMPLATE_PATH }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE }}
          aws-region: ${{ inputs.region }}

      - name: Create Ephemeral Key
        id: ssh-key
        run: |
          KEY_NAME=${{ env.TEMP_SSH_KEY_AWS_NAME }}
          aws ec2 create-key-pair --key-name $KEY_NAME --query 'KeyMaterial' --output text > ${{ env.TEMP_SSH_KEY_FILENAME }}
          chmod 600 ${{ env.TEMP_SSH_KEY_FILENAME }}
          echo "NAME=$KEY_NAME" >> $GITHUB_OUTPUT

      - name: Deploy Infrastructure
        id: deploy
        uses: eshans-nexus/actions-templates/.github/actions/deploy-cfn@main
        with:
          template_file_path: ./${{ env.TEMPLATE_FILENAME }}
          flavor: ${{ inputs.flavor }}
          region: ${{ inputs.region }}
          stack_name: ${{ env.STACK_NAME }}
          vpc_id: ${{ secrets.TEST_VPC_ID }}
          subnet_id: ${{ secrets.TEST_SUBNET_ID }}
          key_name: ${{ steps.ssh-key.outputs.NAME }}

      - name: Verify Deployment (Linux)
        if: contains(inputs.flavor, 'linux')
        env:
          OUTPUTS: ${{ steps.deploy.outputs.stack_outputs }}
        run: |
          # Parse the relevant host connection string from the JSON output
          # Try generic output names or specific ones
          HOST=$(echo $OUTPUTS | jq -r '.HeadnodePublicDNS // .RDPConnection // .ServerAddress')
          
          # Clean HTTPS if present (NLM)
          HOST=$(echo $HOST | sed 's/https:\/\///')
          
          echo "Connecting to $HOST..."
          ssh-keyscan -H $HOST >> ~/.ssh/known_hosts || true
          
          # Simple check command
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$HOST "uptime"

      - name: Verify Deployment (Windows)
        if: contains(inputs.flavor, 'windows')
        env:
          OUTPUTS: ${{ steps.deploy.outputs.stack_outputs }}
        run: |
          HOST=$(echo $OUTPUTS | jq -r '.HeadnodePublicDNS // .RDPSSHConnection')
          echo "Checking RDP Port on $HOST..."
          timeout 300 bash -c "until nc -z -v -w5 $HOST 3389; do sleep 15; done"

      - name: Prepare Scan Inputs
        if: inputs.run_security_scan
        id: prep_scan
        env:
          OUTPUTS: ${{ steps.deploy.outputs.stack_outputs }}
          FLAVOR: ${{ inputs.flavor }}
        run: |
          # 1. Extract Hostname (AWS Specific JSON parsing)
          HOST=$(echo $OUTPUTS | jq -r '.HeadnodePublicDNS // .RDPConnection // .RDPSSHConnection // .ServerAddress')
          HOST=$(echo $HOST | sed 's/https:\/\///')
          
          echo "HOSTNAME=$HOST" >> $GITHUB_OUTPUT

          # 2. Determine OS and User (AWS Specific Logic)
          if [[ "$FLAVOR" == *"windows"* ]]; then
            echo "OS_TYPE=windows" >> $GITHUB_OUTPUT
            echo "USERNAME=Administrator" >> $GITHUB_OUTPUT
          else
            echo "OS_TYPE=linux" >> $GITHUB_OUTPUT
            echo "USERNAME=ubuntu" >> $GITHUB_OUTPUT
          fi

      - name: Run Security Scan
        if: inputs.run_security_scan
        uses: eshans-nexus/actions-templates/.github/actions/run-trivy-scan@main
        with:
          hostname: ${{ steps.prep_scan.outputs.HOSTNAME }}
          username: ${{ steps.prep_scan.outputs.USERNAME }}
          ssh_key_path: ${{ env.TEMP_SSH_KEY_FILENAME }}
          os_type: ${{ steps.prep_scan.outputs.OS_TYPE }}
          asset_name: ${{ inputs.ami_id }}

      - name: Upload Scan Artifacts
        if: inputs.run_security_scan
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SCAN_ARTIFACT_NAME }}
          path: |
            report.json
            report.md

      - name: Cleanup
        if: always()
        run: |
          aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
          aws ec2 delete-key-pair --key-name ${{ steps.ssh-key.outputs.NAME }}